
void routine2_vec(float alpha, float beta) {

    unsigned int i, j;

    __m128 alpha_vec = _mm_set1_ps(alpha);
    __m128 beta_vec = _mm_set1_ps(beta);

    for (i = 0; i < N; i++) {
        __m128 w_vec = _mm_loadu_ps(&w[i]);
        w_vec = _mm_sub_ps(w_vec, beta_vec);
        for (j = 0; j < N; j += 4) {
            __m128 A_vec = _mm_loadu_ps(&A[i][j]);
            __m128 x_vec = _mm_loadu_ps(&x[j]);
            w_vec = _mm_add_ps(w_vec, _mm_mul_ps(alpha_vec, _mm_mul_ps(A_vec, x_vec)));
        }
        _mm_storeu_ps(&w[i], w_vec);
    }
}

    void routine1_vec(float alpha, float beta) {

    unsigned int i;

    __m128 alpha_vec = _mm_set1_ps(alpha);
    __m128 beta_vec = _mm_set1_ps(beta);

    for (i = 0; i < M; i += 4) {
        __m128 y_vec = _mm_loadu_ps(&y[i]);
        __m128 z_vec = _mm_loadu_ps(&z[i]);
        y_vec = _mm_add_ps(_mm_mul_ps(alpha_vec, y_vec), _mm_mul_ps(beta_vec, z_vec));
        _mm_storeu_ps(&y[i], y_vec);
    }

}

void routine_checker() {
    unsigned int i;
    float alpha = 0.023f, beta = 0.045f;

    // Arrays to store the results
    __declspec(align(64)) float y_standard[M], y_vectorized[M];

    // Perform routine1 and store results
    initialize();
    routine1(alpha, beta);
    for (i = 0; i < M; i++) {
        y_standard[i] = y[i];
    }

    // Perform routine1_vec and store results
    initialize();
    routine1_vec(alpha, beta);
    for (i = 0; i < M; i++) {
        y_vectorized[i] = y[i];
    }

    // Compare results
    for (i = 0; i < M; i++) {
        if (y_standard[i] != y_vectorized[i]) {
            printf("Routine1 and routine1_vec produce different results at index %d.\n", i);
            return;
        }
    }

    printf("Routine1 and routine1_vec produce the same results.\n\n");
}
